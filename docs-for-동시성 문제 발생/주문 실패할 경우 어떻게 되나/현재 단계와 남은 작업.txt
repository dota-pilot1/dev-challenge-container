==============================================================================
  주문 실패할 경우 어떻게 되나 - 현재 단계와 남은 작업
==============================================================================


[해결 완료]

  ✓ 1. 중복 승인 → SELECT FOR UPDATE
  ✓ 2. 재고 경합 → 원자적 UPDATE
  ✓ 3. 주문 실패 시 빈 승인 → APPROVE_FAILED + 이력 테이블 + 재시도 API


[현재 주문 실패 시 동작]

  shop-api 호출 실패 (타임아웃, 500, 재고부족 등)
    → participation status = APPROVE_FAILED
    → approval_history에 실패 이력 기록 (사유 포함)
    → 관리자가 "재시도" 버튼으로 다시 시도 가능

  여기까지는 해결됨.


[아직 해결 안 된 주문 실패 시나리오]

  4. 네트워크 응답 유실
     - shop-api가 주문을 만들었는데 응답이 유실됨
     - concurrency-lab은 실패로 판단 → APPROVE_FAILED
     - 재시도하면 주문이 또 생김 (중복 주문)

     해야 할 일:
       - shop-api에 멱등키 도입
       - 주문 요청에 participationId를 포함
       - shop_order 테이블에 participation_id unique 제약조건 추가
       - 같은 participationId로 재요청 시 기존 주문 반환

  5. 주문 성공 후 로컬 커밋 실패 (유령 주문)
     - shop-api 주문 성공 (order_id=42, 재고 차감)
     - concurrency-lab DB 커밋 실패 → 롤백
     - shop-api에는 주문 존재, concurrency-lab에는 기록 없음

     해야 할 일:
       - Saga 패턴: 커밋 실패 시 shop-api 주문 취소 호출
       - 또는 Outbox 패턴: 이벤트 기반 비동기 처리
       - shop-api에 주문 취소 API 필요 (재고 복구 포함)


[다음 단계 추천]

  4번(멱등키) → 5번(Saga) 순서

  4번은 shop-api 쪽 수정:
    - CreateOrderDto에 participationId 필드 추가
    - shop_order 테이블에 participation_id 컬럼 + unique 추가
    - 중복 요청 시 기존 주문 반환
    - ShopClient에서 participationId 전달

  5번은 가장 난이도 높음:
    - 보상 트랜잭션 개념 도입
    - shop-api에 주문 취소 API 추가
    - approve()에서 커밋 실패 감지 후 취소 호출

================================================================================
