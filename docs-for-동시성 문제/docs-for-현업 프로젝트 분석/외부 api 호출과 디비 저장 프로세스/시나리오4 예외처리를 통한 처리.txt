================================================================================
  또 다른 방식: @Transactional 안에서 API 호출 + 실패 시 롤백
================================================================================

  제안자: 팀장님
  핵심: 트랜잭션 안에서 API를 호출하고, 실패하면 RuntimeException으로 롤백
  작업량: 거의 없음 (현재 구조 유지)

================================================================================
  1. 제안된 코드
================================================================================

  @Transactional
  public void saveBrandAndSendApi(BrandDto brandDto) {
      // 1. DB 저장 (아직 Commit 전)
      BrandEntity savedEntity = brandRepository.save(brandDto.toEntity());

      try {
          // 2. 외부 API 전송
          apiClient.sendBrandData(savedEntity);
      } catch (Exception e) {
          // 3. API 실패 시 RuntimeException을 던져서 DB 저장을 롤백시킴
          log.error("API 전송 실패로 인한 DB 롤백 수행", e);
          throw new RuntimeException("API 연동 실패", e);
      }
      // 4. 메서드 정상 종료 시 DB Commit
  }

  논리: "API 실패하면 DB도 롤백하면 되잖아. 간단하고 작업량 없다."

================================================================================
  2. 현재 코드와 비교
================================================================================

  이 방식은 현재 savePartenrBrands()와 본질적으로 동일한 구조임.

  ┌──────────────────────────────────┬──────────────────────────────────┐
  │  팀장님 제안                     │  현재 savePartenrBrands()       │
  ├──────────────────────────────────┼──────────────────────────────────┤
  │  @Transactional                  │  @Transactional                  │
  │  public void save() {            │  public void save() {            │
  │    DB 저장 (미커밋)              │    DB INSERT/UPDATE (미커밋)     │
  │    try {                         │    // API 호출                   │
  │      API 호출                    │    middlewareApiManager           │
  │    } catch (Exception e) {       │      .sendRequest(...)           │
  │      throw RuntimeException(e);  │    // 예외 시 → 자동 롤백       │
  │    }                             │  }                               │
  │  }                               │                                  │
  └──────────────────────────────────┴──────────────────────────────────┘

  차이점: try-catch로 로그를 남기느냐 마느냐 정도.
  본질: 둘 다 @Transactional 안에서 외부 HTTP 호출 → 동일한 위험.

================================================================================
  3. 이 방식의 문제점 3가지
================================================================================

  ※ "API가 실패하면 롤백한다" → 맞음. API 실패 시 롤백은 됨.
     문제는 그 외의 시나리오에서 발생함.

--------------------------------------------------------------------------------
  문제 1: DB 커넥션 장시간 점유 (가장 현실적인 위험)
--------------------------------------------------------------------------------

  @Transactional이 시작되면 DB 커넥션을 점유함.
  API 응답을 기다리는 동안에도 커넥션을 계속 잡고 있음.

  시간 분석:
  ┌─────────────────────────────────────────────────────────┐
  │  DB 작업:     ██ (~50ms)                                │
  │  API 대기:    ████████████████████████████ (~5초)       │
  │  커넥션 점유: ██████████████████████████████ (전체)     │
  │                                                         │
  │  → DB 작업은 1%인데 커넥션을 100% 시간동안 점유         │
  └─────────────────────────────────────────────────────────┘

  동시 요청 시나리오 (HikariCP 기본 풀 = 10개):

  사용자 A: 저장 → 커넥션#1 점유 → API 대기중... (5초)
  사용자 B: 저장 → 커넥션#2 점유 → API 대기중... (5초)
  사용자 C: 저장 → 커넥션#3 점유 → API 대기중... (5초)
    ...
  사용자 J: 저장 → 커넥션#10 점유 → API 대기중... (5초)
  사용자 K: 단순 조회 → ❌ 커넥션 없음 → Connection timeout!
  사용자 L: 단순 조회 → ❌ 커넥션 없음 → 시스템 전체 먹통!

  → FNB+ API가 느려지기만 해도 우리 시스템 전체가 장애.
  → 저장과 무관한 조회 기능까지 전부 영향 받음.

--------------------------------------------------------------------------------
  문제 2: API 성공 + 커밋 실패 = 복구 불가능 (최악의 시나리오)
--------------------------------------------------------------------------------

  @Transactional 안에서의 실행 순서:

  [1] DB INSERT         → 미커밋 상태
  [2] API 호출          → ✅ 성공! (FNB+에 데이터 전송 완료)
  [3] 메서드 종료
  [4] Spring이 커밋 시도 → ❌ 실패! (DB 데드락, 커넥션 끊김 등)
  [5] 자동 롤백         → 우리 DB에서 데이터 사라짐

  결과:
  ┌─────────────────────────────────────────────────┐
  │  FNB+ (외부 DB):  데이터 있음 ✅               │
  │  우리 DB:         데이터 없음 ❌               │
  │                                                 │
  │  → 유령 데이터 발생                             │
  │  → FNB+에는 삭제 API가 없음                    │
  │  → 복구 방법 없음 💀                           │
  └─────────────────────────────────────────────────┘

  "API 실패 시 롤백"은 되지만,
  "API 성공 후 커밋 실패"는 대응할 방법이 없음.

  ※ 커밋 실패 원인 (드물지만 발생 가능):
  - DB 데드락 (다른 트랜잭션과 충돌)
  - DB 커넥션 끊김 (네트워크 순단)
  - 디스크 용량 부족
  - PostgreSQL WAL 장애

--------------------------------------------------------------------------------
  문제 3: 외부 장애 전파 (연쇄 장애)
--------------------------------------------------------------------------------

  외부 시스템(FNB+, GWMS)에 장애가 발생하면:

  정상 시:
    저장 요청 → DB 50ms + API 200ms = 250ms 응답

  FNB+ 장애 시:
    저장 요청 → DB 50ms + API 30초 타임아웃 = 30초 응답
    → 30초 동안 DB 커넥션 1개 점유
    → 5명만 동시 저장해도 커넥션 5개 × 30초 점유
    → 다른 모든 기능 (조회, 다른 메뉴) 전부 대기
    → 우리 서비스 전체가 FNB+ 때문에 죽음

  이것을 "장애 전파" 또는 "연쇄 장애"라고 함.
  외부 시스템 하나의 장애가 우리 시스템 전체를 마비시키는 구조.

================================================================================
  4. 트랜잭션 분리와의 비교
================================================================================

  ┌─────────────┬─────────────────────────┬───────────────────────────┐
  │  항목       │ 팀장님 방식             │ 트랜잭션 분리             │
  │             │ (TX 안에서 API 호출)    │ (TX 밖에서 API 호출)      │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  코드 구조  │ 메서드 1개              │ 메서드 2개 (분리)         │
  │  추가 작업  │ 없음                    │ 메서드 분리만             │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  커넥션     │ API 응답까지 점유       │ DB 작업 후 즉시 반환      │
  │  점유 시간  │ (~5초)                  │ (~50ms)                   │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  API 실패   │ DB 롤백 (데이터 유실)   │ DB는 유지 (데이터 보존)   │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  API 성공 + │ 유령 데이터 발생        │ 발생 안 함                │
  │  커밋 실패  │ (복구 불가)             │ (이미 커밋 완료)          │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  외부 장애  │ 우리 시스템 전체 장애   │ 우리 시스템 정상 동작     │
  │  전파       │ (연쇄 장애)             │ (API만 실패)              │
  ├─────────────┼─────────────────────────┼───────────────────────────┤
  │  동시 10명  │ 커넥션 10개 × 5초 점유  │ 커넥션 10개 × 50ms 점유   │
  │  저장 시    │ = 풀 고갈 위험          │ = 여유 있음               │
  └─────────────┴─────────────────────────┴───────────────────────────┘

================================================================================
  5. 결론
================================================================================

  팀장님 방식의 핵심 문제:
  "API 실패 시 롤백"은 되지만, 그게 전부가 아님.

  ┌──────────────────────────────────────────────────────────┐
  │  ✅ API 실패 → DB 롤백           → 이건 됨             │
  │  ❌ API 성공 + 커밋 실패         → 복구 불가           │
  │  ❌ API 느려짐 → 커넥션 풀 고갈  → 전체 장애           │
  │  ❌ 외부 장애 → 우리 장애 전파   → 연쇄 장애           │
  └──────────────────────────────────────────────────────────┘

  트랜잭션 분리는 "추가 기능 개발"이 아니라 "구조 교정"임.
  메서드를 2개로 쪼개기만 하면 되므로 작업량도 크지 않음.

  최소한의 변경:
  ┌──────────────────────────────────────────────────────────┐
  │  // Controller에서:                                      │
  │  SaveResult result = service.saveToDb(list);  // TX 있음 │
  │  service.callApi(result);                     // TX 없음 │
  │                                                          │
  │  → 이것만으로 위 3가지 문제가 모두 해결됨               │
  │  → 컬럼 추가, 테이블 추가 없이 가능                     │
  │  → 작업량: 메서드 분리 (1~2시간/API당)                  │
  └──────────────────────────────────────────────────────────┘
