================================================================================
  중복 승인 / 재고 경합 해결 방법
================================================================================


[1. 중복 승인 해결 - SELECT FOR UPDATE (비관적 락)]

  문제:
    동시에 같은 참가자를 승인하면 둘 다 SUBMITTED을 읽고 둘 다 주문 생성

  해결:
    approve()에서 participation 조회 시 FOR UPDATE로 행 잠금

  변경 전:
    SELECT ... FROM participation WHERE id = #{id}
    → 락 없음, 동시 읽기 가능

  변경 후:
    SELECT ... FROM participation WHERE id = #{id} FOR UPDATE
    → 먼저 온 요청이 행 잠금
    → 두 번째 요청은 첫 번째 트랜잭션 커밋까지 대기
    → 대기 후 읽으면 이미 APPROVED → 검증 실패 → 주문 생성 안 됨

  수정 파일:
    - ParticipationMapper.java: findByIdForUpdate() 메서드 추가
    - ParticipationMapper.xml: FOR UPDATE 쿼리 추가
    - ParticipationService.java: approve()에서 findByIdForUpdate() 사용


[2. 재고 경합 해결 - 원자적 재고 차감]

  문제:
    SELECT stock → if (stock >= 1) → UPDATE stock = stock - 1
    3단계 사이에 다른 요청이 끼어들면 둘 다 통과 → 초과 판매

  해결:
    확인과 차감을 하나의 UPDATE로 합침

  변경 전:
    SELECT product (stock=1 읽음)
    if (stock < quantity) throw
    UPDATE product SET stock = 1 - 1    ← 애플리케이션에서 계산한 값

  변경 후:
    UPDATE product SET stock = stock - 1
    WHERE id = ? AND stock >= 1         ← DB가 원자적으로 확인+차감
    → affected rows = 0이면 재고 부족

  수정 파일:
    - shop-api/src/order/order.service.ts: create() 메서드 변경

================================================================================


요약 정리:
1. 중복 승인 문제 해결:
선행 과정인 조회에 대해 락 걸어서 동시 업데이트 막는다.

2. 주문 생성시 재고 차감 경합 문제:
방어 2단계:
  - SELECT: 상품이 존재하는지 확인 (없으면 404)
  - UPDATE WHERE stock >= quantity: DB가 원자적으로 재고 확인+차감 (부족하면 400)

2번 문제 해결을 위해 달라진 코드 비교:

  이전: 앱이 비교 + 앱이 계산 (3단계, 틈새 있음)
    SELECT stock → 1
    if (stock < 1) throw        ← 앱이 비교
    UPDATE SET stock = 1 - 1     ← 앱이 계산한 값(0)을 넣음

  현재: DB가 비교 + DB가 계산 (1단계, 원자적)
    UPDATE SET stock = stock - 1 WHERE stock >= 1  ← DB가 비교+계산
    if (affected rows = 0) throw

개념 보충:
원자적 처리:
DB의 UPDATE 문 하나는 실행 중에 다른 요청이 끼어들 수 없습니다. DB 엔진이 보장하는 겁니다.

**앱에서 3단계로 하면:**
```
SELECT stock → 1       ← 여기서 다른 요청이 끼어들 수 있음
if (stock >= 1)        ← 여기서도
UPDATE SET stock = 0   ← 여기서도
```

**DB에서 1문장으로 하면:**
```
UPDATE SET stock = stock - 1 WHERE stock >= 1
```
이 한 문장이 실행되는 동안 다른 요청은 대기합니다. 확인과 차감이 쪼개지지 않고 한 번에 처리되니까 "원자적(atomic)"이라고 하는 겁니다.
