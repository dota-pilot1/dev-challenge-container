■ 문제 4: 멱등성 키 (Idempotency Key)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

▶ 무슨 문제?

  승인 버튼 클릭 → shop-api에 주문 요청 → 주문 생성 성공
  → 그런데 응답이 돌아오는 도중 네트워크 끊김
  → concurrency-lab은 실패로 판단 → APPROVE_FAILED
  → 재시도 버튼 클릭 → shop-api에 또 주문 요청 → 주문이 2개 생김

  결과: 같은 참가에 대해 주문이 중복 생성, 재고도 2번 차감됨

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

▶ 현재 코드의 문제점

  1) ShopClient.createOrder() - 매번 새로운 요청으로 취급
     → 멱등성 키 없이 POST /orders 호출

  2) shop-api order.service.ts - 요청마다 무조건 새 주문 생성
     → 중복 체크 로직 없음

  3) retryApprove() - 재시도할 때도 똑같이 createOrder() 호출
     → 이전 요청이 성공했는지 확인 불가

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

▶ 해결 방법: 멱등성 키

  핵심: "같은 요청이면 같은 결과를 돌려줘라"

  흐름:
  1) concurrency-lab이 주문 요청 시 고유 키를 함께 전송
     - 키 = "participation-{participationId}" (참가 ID당 1개)

  2) shop-api가 주문 생성 전에 해당 키로 이미 주문이 있는지 확인
     - 있으면 → 기존 주문 반환 (새로 만들지 않음)
     - 없으면 → 새 주문 생성

  결과: 재시도해도 주문은 1개만 생김

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

핵심 요약:
// approve()에서든 retryApprove()에서든
String idempotencyKey = "participation-" + participationId;
를 멱등성 키로 해서 주문 생성되게 하고 나중에 재요청시 이걸 이용해 이미 생성된 주문인지 판단하겠다가 핵심이고
주문 테이블에 칼럼을 추가해서 이 키를 가지고 있겠다 이렇게가 요약 맞지?
