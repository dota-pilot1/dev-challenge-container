1. 재시도 메커니즘 필요
이유: 주문 생성이 실패할수도 있다.

2. 멱등성 키 필요
실제로는 주문이 생성 됐지만 요청 정보가 제대로 업데이트 되지 않을 수 있다.

3. 보상 트랜잭션:
주문 생성은 성공 했는데 참가 정보에 해당 주문 정보가 업데이트 되지 않는다면 주문 정보는 출처가 없는 주문 정보가 되고 어떤 참가에 대한 주문인지 알수 없게 된다.

이런 문제를 방지 하기 위해 try catch 로 주문 생성후에 참가 정보를 업데이트할떄 실패할 가능성을 미리 예측 하고 실패할 경우 주문도 취소 하도록 안전 장치를 만든다.

4. 동시 승인 방지:
참가에 대한 승인 요청이 동시성으로 이루어질 경우 동시성 문제로 승인 요청이 2개 생성되는 경우가 발생할수 있으므로 승인 바로 전단계인 참가 조회에 락을 걸어서 승인 단계에서 중복이 발생하지 않도록 한다.

5. 레이스 컨디션:
재고 판단을 재고 업데이트 이전에 코드상에서 하면 동시성 문제로 재고가 잘못 계산 될 수 있다. 그래서 쿼리상에서 재고 개수 확인과 업데이트를 동시에 해야 한다.

중요도 순위:
기본적으로 외부 api 를 한트랜잭션 안에서 관리할수 없는것에 대한 안전 장치 혹은 후속 조취 설정이므로

1번의 재시도 메커니즘과 2번의 중복 방지가 가장 중요하며 3번과 4번은 모두 고려하면 좋지만 서비스 규모에 따라 재량껏 구현 여부를 결정할수 있는 여지가 상대적으로 크다고 봐야 한다.

총요약2:
주문과 재고 처리에 대한 동시성 문제를 거의 종합적으로 다루므로 위의 5가지 조취를 필요한곳에 모두 적용한다면 주문 /재고 처리가 있는 서비스의 동시성 문제는 거의 완벽하게 해결 가능하다라고 할 수 있다.
