요청 스펙
=========


1. GET /api/members — 전체 회원 조회
=====================================
  Method : GET
  URL    : /api/members
  Body   : 없음
  Header : Content-Type 불필요

  파라미터 없이 호출하면 전체 회원 목록을 반환한다.


2. POST /api/members/save — 일괄 저장
======================================
  Method : POST
  URL    : /api/members/save
  Header : Content-Type: application/json
  Body   :

  {
    "rows": [                        — 변경된 행 목록 (배열)
      {
        "id"       : Long | null     — 회원 PK (C일 때는 null 또는 생략)
        "email"    : String          — 이메일
        "nickname" : String          — 닉네임
        "status"   : String          — 처리 구분 ("C" | "U" | "D")
      }
    ]
  }


[status 필드 상세]

  "C" (Create) — 신규 등록
    필수: email, nickname
    불필요: id (null 또는 생략)
    처리: existsByEmail 중복 체크 → insert
    비밀번호: 서버에서 기본값 자동 부여

  "U" (Update) — 수정
    필수: id, nickname
    포함: email (변경하지 않더라도 전송)
    처리: findById 존재 확인 → nickname 업데이트, updated_at 갱신

  "D" (Delete) — 삭제
    필수: id
    포함: email, nickname (참조용, 서버에서 사용하지 않음)
    처리: findById 존재 확인 → deleteById


[요청 예시 — 복합 (C + U + D)]
  {
    "rows": [
      { "email": "new@test.com", "nickname": "신규유저", "status": "C" },
      { "id": 2, "email": "terecal2@daum.net", "nickname": "수정닉네임", "status": "U" },
      { "id": 3, "email": "terecal3@daum.net", "nickname": "삭제대상", "status": "D" }
    ]
  }


[프론트엔드 → 백엔드 데이터 매핑]

  프론트 (members.tsx)             백엔드 (MemberSaveRequest)
  _flag: "C"                  →     status: "C"
  _flag: "U"                  →     status: "U"
  deletedRows._flag: "D"      →     status: "D"

  프론트에서는 _flag로 관리하고, 서버 전송 시 status로 변환한다.


[DB 반영 쿼리 매핑]

  status | Mapper 메서드    | SQL
  -------|------------------|----------------------------------------
  C      | insert()         | INSERT INTO member (email, password, nickname, created_at, updated_at) VALUES (...)
  U      | update()         | UPDATE member SET nickname = ?, updated_at = NOW() WHERE id = ?
  D      | deleteById()     | DELETE FROM member WHERE id = ?
