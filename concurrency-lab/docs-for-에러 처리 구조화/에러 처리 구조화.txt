1. 에러 처리 아키텍쳐

com.opro.concurrency/
├── dto/
│   └── ErrorResponse.java          ← 이 JSON 형태를 정의한 DTO
├── exception/
│   ├── ErrorCode.java              ← 에러 종류 목록 (enum)
│   ├── CustomException.java        ← 예외 던지는 클래스
│   └── GlobalExceptionHandler.java ← 모든 예외를 ErrorResponse로 변환
└── config/
    └── SecurityConfig.java         ← 401/403도 ErrorResponse로 변환


2. 에러에 대한 주요 정보를 명시 with 클래스

@Getter
@RequiredArgsConstructor
public enum ErrorCode {

    // Auth
    AUTH_REQUIRED(HttpStatus.UNAUTHORIZED, "AUTH_401", "인증이 필요합니다"),
    INVALID_CREDENTIALS(HttpStatus.UNAUTHORIZED, "AUTH_401_INVALID", "이메일 또는 비밀번호가 올바르지 않습니다"),
    ACCESS_DENIED(HttpStatus.FORBIDDEN, "AUTH_403", "접근 권한이 없습니다"),
    TOKEN_EXPIRED(HttpStatus.UNAUTHORIZED, "AUTH_401_EXPIRED", "토큰이 만료되었습니다"),

    // User
    DUPLICATE_EMAIL(HttpStatus.CONFLICT, "USER_409", "이미 등록된 이메일입니다"),
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, "USER_404", "사용자를 찾을 수 없습니다"),


3. 스프링 차원에서 에러 응답 형식을 지정

    // 일반 Controller - 정상 응답
    @PostMapping("/signup")
    public ResponseEntity<AuthResponse> signup(...) {
        return ResponseEntity.status(201).body(authResponse);  // ← JSON 응답
    }

    @RestControllerAdvice
    public class GlobalExceptionHandler {

        @ExceptionHandler(CustomException.class)
        public ResponseEntity<ErrorResponse> handleCustom(CustomException ex, HttpServletRequest request) {
            return ResponseEntity
                    .status(ex.getErrorCode().getStatus())
                    .body(ErrorResponse.of(ex.getErrorCode(), request.getRequestURI()));
        }


4. 필요한 부분에서 에러를 던짐
// AuthService.java
throw new CustomException(ErrorCode.DUPLICATE_EMAIL);
