=====================================
챌린지 제출 — 전체 프로세스
=====================================

■ 전체 흐름 요약

  챌린지 생성 → 참가 신청 → 과제 제출 → 승인/반려 → 보상 지급


■ 상세 프로세스

1. 챌린지 생성 (관리자)
   - 제목, 설명, 보상 상품(shop-api 상품), 보상 수량 설정
   - POST /api/challenges
   - 상태: ACTIVE

2. 참가 신청 (사용자)
   - 챌린지에 참가 신청
   - POST /api/participations { challengeId, userId }
   - 참가 상태: APPLIED
   - 제약: 한 챌린지에 같은 사용자는 1번만 참가 가능 (UNIQUE 제약)

3. 과제 제출 (사용자)
   - GitHub PR 링크 등 제출물 URL 입력
   - PATCH /api/participations/{id}/submit { submissionUrl }
   - 참가 상태: APPLIED → SUBMITTED
   - 제약: APPLIED 상태에서만 제출 가능

4. 승인 (관리자)
   - 제출물 검토 후 승인
   - PATCH /api/participations/{id}/approve
   - 내부 동작:
     ① 비관적 락으로 참가 행 잠금 (동시 승인 방지)
     ② 상태 검증 (SUBMITTED인지 확인)
     ③ shop-api에 주문 생성 요청 (멱등성 키 포함)
     ④ 주문 성공 → 참가 상태 APPROVED + 주문 ID 저장
     ⑤ 주문 실패 → 참가 상태 APPROVE_FAILED + 이력 기록
     ⑥ 후속 처리 실패 → 보상 트랜잭션 (주문 취소)
   - 참가 상태: SUBMITTED → APPROVED 또는 APPROVE_FAILED

5. 반려 (관리자)
   - 제출물 부적합 시 반려
   - PATCH /api/participations/{id}/reject
   - 참가 상태: SUBMITTED → REJECTED
   - 주문 생성 없음

6. 재시도 (관리자)
   - 승인 실패 후 문제 해결 뒤 재시도
   - PATCH /api/participations/{id}/retry-approve
   - 동일 멱등성 키 사용 → 중복 주문 방지
   - 참가 상태: APPROVE_FAILED → APPROVED 또는 APPROVE_FAILED (유지)

7. 참가 취소 (사용자)
   - 제출 전에만 취소 가능
   - DELETE /api/participations/{id}
   - 참가 행 삭제 (hard delete)
   - 제약: APPLIED 상태에서만 가능


■ 상태 전이

  APPLIED
    ├─ → SUBMITTED (제출)
    └─ → 삭제 (참가 취소)

  SUBMITTED
    ├─ → APPROVED (승인 성공)
    ├─ → APPROVE_FAILED (승인 실패)
    └─ → REJECTED (반려)

  APPROVE_FAILED
    ├─ → APPROVED (재시도 성공)
    └─ → APPROVE_FAILED (재시도 실패, 무한 재시도 가능)

  APPROVED, REJECTED → 최종 상태 (더 이상 전이 없음)


■ 서비스 간 통신

  관리자 → devquest-web (React)
            → concurrency-lab (Spring Boot) — 챌린지/참가 관리
              → shop-api (NestJS) — 주문 생성/취소, 재고 차감/복구

  통신 방식: REST API (동기 HTTP 호출)
  DB 분리: concurrency-lab DB (참가, 이력) / shop-api DB (상품, 주문)


■ 적용된 동시성 패턴 (승인 단계)

  1. 비관적 락 — 동시 승인 방지
  2. 멱등성 키 — 재시도 시 중복 주문 방지
  3. 원자적 재고 차감 — Race Condition 방지
  4. 보상 트랜잭션 — 후속 처리 실패 시 주문 취소
  5. 재시도 메커니즘 — 실패 상태 저장 + 재시도 경로 제공
