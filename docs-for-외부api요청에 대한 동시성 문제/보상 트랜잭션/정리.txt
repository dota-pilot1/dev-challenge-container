## 보상 트랜잭션 — Saga 패턴

### 문제
주문 생성(shop-api)은 성공했는데 후속 처리(내부 DB 업데이트)가 실패하면?

  1. shopClient.createOrder()  → 성공 (주문 #4 생성, 재고 차감됨)
  2. participationMapper.updateOrderId()  → 실패! (DB 에러)
  3. participationMapper.updateStatus("APPROVED")  → 실행 안 됨

결과:
  - shop-api: 주문 #4 존재, 재고 차감됨
  - concurrency-lab: 참가 상태는 그대로, 주문 ID 미반영
  → "유령 주문" 발생

@Transactional로 롤백해도 외부 API 호출(shop-api)은 되돌릴 수 없음.
→ 분산 시스템에서 트랜잭션이 양쪽 DB에 걸쳐있을 때 발생하는 근본적인 문제.


### 해결: 보상 트랜잭션 (Compensating Transaction)

후속 처리가 실패하면 shop-api에 주문 취소 요청을 보낸다.

  try {
      // 외부 API 호출
      Map<String, Object> order = shopClient.createOrder(...);
      Integer orderId = ((Number) order.get("id")).intValue();

      try {
          // 후속 처리 (내부 DB)
          participationMapper.updateOrderId(id, orderId);
          participationMapper.updateStatus(id, "APPROVED");
          approvalHistoryMapper.insert(...);
      } catch (Exception postEx) {
          // 후속 처리 실패 → 보상 트랜잭션
          try {
              shopClient.cancelOrder(orderId);  // 주문 취소 + 재고 복구
          } catch (Exception compensateEx) {
              log.error("보상 트랜잭션 실패! 수동 확인 필요: orderId={}", orderId);
          }
          participationMapper.updateStatus(id, "APPROVE_FAILED");
      }
  } catch (Exception e) {
      // 주문 자체 실패 → 보상 불필요
      participationMapper.updateStatus(id, "APPROVE_FAILED");
  }


### 3단계 방어
1. 주문 실패 → 바깥 catch, APPROVE_FAILED 처리
2. 후속 처리 실패 → 보상 트랜잭션으로 주문 취소
3. 보상 트랜잭션도 실패 → 로그에 "수동 확인 필요" 기록


### cancelOrder 구현

  ShopClient:
    public void cancelOrder(int orderId) {
        restClient
            .patch()
            .uri("/orders/{id}/status", orderId)
            .body(Map.of("status", "CANCELLED"))
            .retrieve()
            .toBodilessEntity();
    }

  shop-api (기존 로직 활용):
    - CANCELLED로 상태 변경 시 자동으로 재고 복구
    - stock = stock + order.quantity


### 한계
보상 트랜잭션 자체도 실패할 수 있다.
→ 네트워크 장애, shop-api 다운 등

실무에서의 추가 대응:
  - Outbox 패턴: DB에 이벤트를 먼저 저장, 별도 프로세스가 외부 API 호출
  - 메시지 큐: 주문 요청을 큐에 넣고 비동기 처리
  - 불일치 감지 스케줄러: 주기적으로 양쪽 DB 비교 후 보정

현실적으로 후속 처리(단순 UPDATE)가 실패할 확률은 매우 낮지만,
"외부 API 호출 후에는 보상을 고려해야 한다"는 설계 원칙을 코드로 남겨둔 것.


### 적용 위치
- concurrency-lab/.../client/ShopClient.java — cancelOrder()
- concurrency-lab/.../service/ParticipationService.java — approve(), retryApprove()
- shop-api/src/order/order.service.ts — updateStatus() (취소 시 재고 복구)
