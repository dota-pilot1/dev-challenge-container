## 멱등성 키 — 중복 주문 방지

### 문제
네트워크 응답이 유실되면 클라이언트는 요청이 성공했는지 알 수 없다.
→ 재시도하면 같은 주문이 2번 생성될 수 있음.

예시:
  concurrency-lab → shop-api: 주문 생성 요청
  shop-api: 주문 생성 성공 (주문 #4)
  shop-api → concurrency-lab: 응답 전송 (네트워크 유실!)
  concurrency-lab: 타임아웃 → 실패로 판단 → 재시도
  shop-api: 또 주문 생성 (주문 #5) ← 중복!


### 해결: 멱등성 키 (Idempotency Key)

같은 키로 요청하면 새로 생성하지 않고 기존 결과를 반환한다.

키 생성 방식: "participation-{참가ID}"
  → 결정적(deterministic)이라 별도 저장 불필요
  → 같은 참가에 대한 주문은 항상 같은 키


### 구현

1. shop-api — orders 테이블에 idempotency_key 컬럼 (UNIQUE)

2. shop-api — order.service.ts create()에서 키 체크:

  if (dto.idempotencyKey) {
    const [existing] = await db
      .select().from(orders)
      .where(eq(orders.idempotencyKey, dto.idempotencyKey))
      .limit(1);

    if (existing) {
      return existing;  // 이미 있으면 기존 주문 반환
    }
  }

3. concurrency-lab — approve()/retryApprove()에서 키 전달:

  String idempotencyKey = "participation-" + id;
  shopClient.createOrder(..., idempotencyKey, ...);


### 왜 participation ID 기반인가?
- 하나의 참가에 대해 주문은 1건만 생성되어야 함
- UUID를 쓰면 재시도 시 다른 키가 생성되어 중복 방지가 안 됨
- participation-{id}는 항상 동일하므로 재시도해도 같은 키 → 중복 방지


### 테스트 방법
프론트에 "더블 재시도" 버튼:
  - Promise.all로 같은 retryApprove API를 동시에 2번 호출
  - 둘 다 같은 멱등성 키로 shop-api에 요청
  - 먼저 도착한 요청이 주문 생성, 두 번째는 기존 주문 반환
  - 결과: 주문 1건만 생성됨


### 적용 위치
- shop-api/src/database/schema.ts — orders 테이블 idempotency_key 컬럼
- shop-api/src/order/dto/create-order.dto.ts — idempotencyKey 필드
- shop-api/src/order/order.service.ts — create() 멱등성 체크
- concurrency-lab/.../client/ShopClient.java — idempotencyKey 파라미터
- concurrency-lab/.../service/ParticipationService.java — "participation-" + id
