================================================================================
  savePartenrBrands() 함수 구간 분석
  - 어디가 DB 저장이고, 어디가 외부 API 호출인지
  - 중계서버 때문에 트랜잭션 분리가 더 까다로운지
================================================================================


1. 코드 구간별 분석
================================================================================

  @Transactional  <-- 여기서부터 메서드 끝까지 DB 커넥션 점유
  public void savePartenrBrands(...) throws Exception {


  [구간 1] DB 저장 (트랜잭션이 필요한 구간) -- 소요: 수 ms
  --------------------------------------------------------------------------

      for (PartnerBrandReqDto partnerBrand : partnerBrandReqList) {
          String status = partnerBrand.getStatus();

          if ("C".equals(status)) {
              airstarBrandMapper.insertPartnerBrand(partnerBrand);  // ← DB INSERT
              // regList에 DTO 추가 (외부 API 전송용 데이터 준비)
          }
          else if ("U".equals(status)) {
              airstarBrandMapper.updatePartnerBrand(partnerBrand);  // ← DB UPDATE
              // upList에 DTO 추가
          }
      }

      ** 여기서 트랜잭션이 끝나고 커넥션이 반환되어야 하는데... 안 됨 **


  [구간 2] 외부 API 호출 - 등록 CP204 (트랜잭션 불필요) -- 소요: 수 초 ~ 수십 초
  --------------------------------------------------------------------------

      if (!regList.isEmpty()) {
          // DB 조회: 인터페이스 정보 (destination URL, method 등)
          MiddlewareReqDto regReqDto = middlewareApiManager.getInterfaceInfo("CP204");
          regReqDto.setBody(regReqData);

          // 네트워크 호출: BO -> 중계서버 -> Airstar 플랫폼
          ResponseEntity<...> regRes = middlewareApiManager.sendRequest(regReqDto, ...);
          //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          //                           이 동안 DB 커넥션 점유 중 (불필요)
      }


  [구간 3] 외부 API 호출 - 수정 CP206 (트랜잭션 불필요) -- 소요: 수 초 ~ 수십 초
  --------------------------------------------------------------------------

      if (!upList.isEmpty()) {
          MiddlewareReqDto upReqDto = middlewareApiManager.getInterfaceInfo("CP206");
          upReqDto.setBody(upReqData);

          ResponseEntity<...> upRes = middlewareApiManager.sendRequest(upReqDto, ...);
          //                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          //                          이것도 DB 커넥션 점유 중 (불필요)
      }

  }  // <-- 여기서야 @Transactional 종료, 커넥션 반환


2. 커넥션 점유 시간 비교
================================================================================

  구간 1 (DB 저장):     ██  수십 ms                <-- 트랜잭션 필요
  구간 2 (API CP204):   ████████████████  수 초     <-- 트랜잭션 불필요
  구간 3 (API CP206):   ████████████████  수 초     <-- 트랜잭션 불필요
                        ↑                        ↑
                     커넥션 획득               커넥션 반환

  실제 DB 작업 비율:       약 1~2%
  불필요한 점유 비율:      약 98~99%

  HikariCP 풀 크기 10개 기준, 동시 요청 10건이면 커넥션 풀 고갈.
  다른 모든 DB 작업(조회, 다른 저장 등)이 블로킹되는 연쇄 장애 가능.


3. 중계서버 때문에 트랜잭션 분리가 더 까다로운가?
================================================================================

  결론: 네, 실무가 더 까다롭다. 이유는 3가지.


  [이유 1] 네트워크 홉이 더 많다 (3-hop vs 2-hop)
  --------------------------------------------------------------------------

      실무:  Service -> 중계서버 -> Airstar    (왕복 2번 = 지연 2배)
      랩:    Service -> shop-api               (왕복 1번)

      중계서버를 거치므로 API 응답 시간이 더 길어지고,
      그만큼 커넥션 점유 시간도 길어진다.


  [이유 2] API 호출이 2번으로 나뉜다
  --------------------------------------------------------------------------

      실무:  CP204(등록) 따로 + CP206(수정) 따로  = 최대 2번 호출
      랩:    /register-batch 1번으로 통합

      등록 건과 수정 건이 동시에 있으면 외부 호출을 2번 기다려야 한다.
      커넥션 점유 시간이 2배로 늘어나는 셈.


  [이유 3] 부분 성공 처리가 필요하다
  --------------------------------------------------------------------------

      등록(CP204)은 성공했는데 수정(CP206)이 실패하면?
      - 현재: @Transactional이 전체를 감싸므로, 수정 API 실패 시
              DB INSERT까지 롤백 (이미 외부에 등록된 데이터는 롤백 불가)
      - 개선 시: 등록/수정 각각의 성공/실패를 독립적으로 처리해야 함
              -> 비즈니스 정책 결정 필요 (부분 성공 허용? 보상 트랜잭션?)


4. 하지만 분리 자체는 동일한 패턴으로 가능하다
================================================================================

  중계서버 존재 여부와 관계없이 트랜잭션 분리 방법은 동일하다.
  중계서버는 "호출 경로"의 문제이고, 트랜잭션 분리는 "경계 설정"의 문제.

  [현재 구조 - 문제]

      @Transactional
      savePartenrBrands() {
          DB INSERT/UPDATE          ← 트랜잭션 필요
          sendRequest(CP204)        ← 트랜잭션 불필요 (커넥션 점유)
          sendRequest(CP206)        ← 트랜잭션 불필요 (커넥션 점유)
      }

  [개선 구조 - 랩과 동일한 패턴 적용]

      savePartenrBrands() {         ← 트랜잭션 없음 (오케스트레이터)

          saveBrandsToDb(list);     ← TX#1: DB INSERT/UPDATE만 (커밋 → 커넥션 반환)

          sendRequest(CP204);       ← TX 밖: 중계서버 경유해도 상관없음
          sendRequest(CP206);       ← TX 밖: 커넥션 점유 없음

          updateSyncResults();      ← TX#2: 결과 업데이트 (성공/실패 기록)
      }

  sendRequest()를 @Transactional 밖으로 빼기만 하면 된다.
  중계서버를 거치든 직접 호출하든 분리 패턴은 동일.


5. 요약
================================================================================

  +----------+----------------------------+-----------------------------------+
  | 구간     | 내용                       | 트랜잭션 필요 여부                |
  +----------+----------------------------+-----------------------------------+
  | 구간 1   | DB INSERT/UPDATE           | O (필요)                          |
  | 구간 2   | 중계서버 경유 등록 (CP204) | X (불필요 - 커넥션 낭비)          |
  | 구간 3   | 중계서버 경유 수정 (CP206) | X (불필요 - 커넥션 낭비)          |
  +----------+----------------------------+-----------------------------------+

  중계서버 때문에 더 까다로운 점:
  - 네트워크 홉이 많아 응답 시간이 더 길다 (커넥션 점유 증가)
  - API 호출이 2번으로 나뉘어 점유 시간이 2배
  - 부분 성공 처리에 대한 비즈니스 정책 결정 필요

  하지만 분리 자체는 가능하다:
  - sendRequest()를 @Transactional 밖으로 빼는 것은 동일한 패턴
  - 중계서버는 "호출 경로"의 문제, 트랜잭션 분리는 "경계 설정"의 문제

================================================================================
