# Step 1: 코드 변경 상세

## BrandService.java 변경

### AS-IS (변경 전 전체 코드)

```java
package com.opro.concurrency.service;

import com.opro.concurrency.client.BrandSyncClient;
import com.opro.concurrency.dto.BrandSaveRequest;
import com.opro.concurrency.entity.Brand;
import com.opro.concurrency.exception.CustomException;
import com.opro.concurrency.exception.ErrorCode;
import com.opro.concurrency.mapper.BrandMapper;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class BrandService {

    private final BrandMapper brandMapper;
    private final BrandSyncClient brandSyncClient;

    public List<Brand> findAll() {
        return brandMapper.findAll();
    }

    public Brand findById(Long id) {
        return brandMapper
            .findById(id)
            .orElseThrow(() -> new CustomException(ErrorCode.BRAND_NOT_FOUND));
    }

    public List<Brand> findBySyncStatus(String syncStatus) {
        return brandMapper.findBySyncStatus(syncStatus);
    }

    @Transactional
    public void deleteAll() {
        brandMapper.deleteAll();
    }

    @Transactional
    public void delete(Long id) {
        Brand brand = brandMapper
            .findById(id)
            .orElseThrow(() -> new CustomException(ErrorCode.BRAND_NOT_FOUND));
        brandMapper.deleteById(id);

        // 외부 서버에도 삭제 동기화
        brandSyncClient.deleteBrand(brand.getBrandCode());
    }

    /**
     * [문제 재현용] 실무 코드와 동일한 패턴
     * @Transactional 안에서 DB 저장 + 외부 API 호출을 같이 수행
     *
     * 문제점:
     * 1. 외부 API 성공 → 후속 처리 중 예외 → DB 롤백, 외부는 이미 반영됨
     * 2. DB 저장 후 외부 API 타임아웃 → 트랜잭션 장시간 점유 (커넥션 낭비)
     * 3. 동시 요청 시 같은 brandCode에 대해 경합 발생
     */
    @Transactional  // ← 하나의 트랜잭션이 DB 저장 + 외부 API + syncStatus 업데이트를 전부 감쌈
    public void saveAndSync(BrandSaveRequest request) {
        List<Map<String, Object>> syncList = new ArrayList<>();
        List<Long> savedBrandIds = new ArrayList<>();

        // 1단계: DB 저장 (실무 코드의 for 루프와 동일)
        for (BrandSaveRequest.BrandRow row : request.getRows()) {
            log.info(
                "saveAndSync row: status={}, id={}, brandCode={}, brandNameKo={}",
                row.getStatus(),
                row.getId(),
                row.getBrandCode(),
                row.getBrandNameKo()
            );
            switch (row.getStatus()) {
                case "C" -> {
                    Brand brand = Brand.builder()
                        .brandCode(row.getBrandCode())
                        .shopId(row.getShopId())
                        .steId(row.getSteId())
                        .brandNameKo(row.getBrandNameKo())
                        .brandNameEn(row.getBrandNameEn())
                        .brandDesc(row.getBrandDesc())
                        .useYn(row.getUseYn())
                        .build();
                    brandMapper.insert(brand);
                    savedBrandIds.add(brand.getId());

                    Map<String, Object> syncData = new HashMap<>();
                    syncData.put("brandCode", row.getBrandCode());
                    syncData.put("shopId", row.getShopId());
                    syncData.put("brandMid", row.getSteId());
                    syncData.put("brandNameKo", row.getBrandNameKo());
                    syncData.put("brandNameEn", row.getBrandNameEn());
                    syncData.put("brandDesc", row.getBrandDesc());
                    syncData.put("useYn", row.getUseYn());
                    syncList.add(syncData);
                }
                case "U" -> {
                    Brand brand = brandMapper
                        .findById(row.getId())
                        .orElseThrow(() ->
                            new CustomException(ErrorCode.BRAND_NOT_FOUND)
                        );
                    brand.setBrandNameKo(row.getBrandNameKo());
                    brand.setBrandNameEn(row.getBrandNameEn());
                    brand.setBrandDesc(row.getBrandDesc());
                    brand.setUseYn(row.getUseYn());
                    brandMapper.update(brand);
                    savedBrandIds.add(brand.getId());

                    Map<String, Object> syncData = new HashMap<>();
                    syncData.put("brandCode", row.getBrandCode());
                    syncData.put("shopId", row.getShopId());
                    syncData.put("brandMid", row.getSteId());
                    syncData.put("brandNameKo", row.getBrandNameKo());
                    syncData.put("brandNameEn", row.getBrandNameEn());
                    syncData.put("brandDesc", row.getBrandDesc());
                    syncData.put("useYn", row.getUseYn());
                    syncList.add(syncData);
                }
                default -> log.warn("알 수 없는 status: {}", row.getStatus());
            }
        }

        // 2단계: 같은 트랜잭션 안에서 외부 API 호출 (문제의 핵심!)
        if (!syncList.isEmpty()) {
            log.info("외부 플랫폼 동기화 요청: {}건", syncList.size());
            brandSyncClient.registerBrands(syncList);
            log.info("외부 플랫폼 동기화 완료");

            // 동기화 성공 시 syncStatus 업데이트
            for (Long brandId : savedBrandIds) {
                brandMapper.updateSyncStatus(brandId, "SUCCESS", null);
            }
        }
    }

    @Transactional
    public void saveAll(BrandSaveRequest request) {
        for (BrandSaveRequest.BrandRow row : request.getRows()) {
            switch (row.getStatus()) {
                case "C" -> {
                    Brand brand = Brand.builder()
                        .brandCode(row.getBrandCode())
                        .shopId(row.getShopId())
                        .steId(row.getSteId())
                        .brandNameKo(row.getBrandNameKo())
                        .brandNameEn(row.getBrandNameEn())
                        .brandNameJp(row.getBrandNameJp())
                        .brandNameZhCn(row.getBrandNameZhCn())
                        .brandNameZhTw(row.getBrandNameZhTw())
                        .brandDesc(row.getBrandDesc())
                        .useYn(row.getUseYn())
                        .build();
                    brandMapper.insert(brand);
                }
                case "U" -> {
                    Brand brand = brandMapper
                        .findById(row.getId())
                        .orElseThrow(() ->
                            new CustomException(ErrorCode.BRAND_NOT_FOUND)
                        );

                    brand.setBrandNameKo(row.getBrandNameKo());
                    brand.setBrandNameEn(row.getBrandNameEn());
                    brand.setBrandNameJp(row.getBrandNameJp());
                    brand.setBrandNameZhCn(row.getBrandNameZhCn());
                    brand.setBrandNameZhTw(row.getBrandNameZhTw());
                    brand.setBrandDesc(row.getBrandDesc());
                    brand.setUseYn(row.getUseYn());

                    if (row.getVersion() != null) {
                        brand.setVersion(row.getVersion());
                        int updated = brandMapper.updateWithVersion(brand);
                        if (updated == 0) {
                            throw new CustomException(
                                ErrorCode.BRAND_VERSION_CONFLICT
                            );
                        }
                    } else {
                        brandMapper.update(brand);
                    }
                }
            }
        }
    }
}
```

---

### TO-BE (변경 후 전체 코드)

```java
package com.opro.concurrency.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.opro.concurrency.client.BrandSyncClient;
import com.opro.concurrency.dto.BrandSaveRequest;
import com.opro.concurrency.entity.Brand;
import com.opro.concurrency.entity.BrandSyncHistory;
import com.opro.concurrency.exception.CustomException;
import com.opro.concurrency.exception.ErrorCode;
import com.opro.concurrency.mapper.BrandMapper;
import com.opro.concurrency.mapper.BrandSyncHistoryMapper;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j
@Service
@RequiredArgsConstructor
public class BrandService {

    private final BrandMapper brandMapper;
    private final BrandSyncHistoryMapper brandSyncHistoryMapper;
    private final BrandSyncClient brandSyncClient;
    private final ObjectMapper objectMapper;

    public List<Brand> findAll() {
        return brandMapper.findAll();
    }

    public Brand findById(Long id) {
        return brandMapper
            .findById(id)
            .orElseThrow(() -> new CustomException(ErrorCode.BRAND_NOT_FOUND));
    }

    public List<Brand> findBySyncStatus(String syncStatus) {
        return brandMapper.findBySyncStatus(syncStatus);
    }

    @Transactional
    public void deleteAll() {
        brandMapper.deleteAll();
    }

    @Transactional
    public void delete(Long id) {
        Brand brand = brandMapper
            .findById(id)
            .orElseThrow(() -> new CustomException(ErrorCode.BRAND_NOT_FOUND));
        brandMapper.deleteById(id);

        // 외부 서버에도 삭제 동기화
        brandSyncClient.deleteBrand(brand.getBrandCode());
    }

    /**
     * 통합 메서드 (트랜잭션 없음 — 각 단계가 자체 트랜잭션)
     *
     * [개선 전] @Transactional 안에서 DB 저장 + 외부 API 호출 → 커넥션 장시간 점유, 정합성 문제
     * [개선 후] DB 저장(TX#1) → 커밋 → 외부 API 호출(트랜잭션 없음) → 결과 업데이트(TX#2)
     */
    public void saveAndSync(BrandSaveRequest request) {
        // 1. DB 저장 (트랜잭션 #1 — 커밋 후 커넥션 반환)
        List<Long> savedIds = saveBrands(request);

        // 2. 외부 API 호출 (트랜잭션 밖 — DB 커넥션 점유 안함)
        //    + 결과 업데이트 (트랜잭션 #2)
        if (!savedIds.isEmpty()) {
            syncToExternal(savedIds);
        }
    }

    /**
     * DB 저장만 수행 (INSERT/UPDATE + syncStatus=PENDING)
     * 트랜잭션 커밋 후 DB 커넥션 즉시 반환
     */
    @Transactional
    public List<Long> saveBrands(BrandSaveRequest request) {
        List<Long> savedBrandIds = new ArrayList<>();

        for (BrandSaveRequest.BrandRow row : request.getRows()) {
            log.info(
                "saveBrands row: status={}, id={}, brandCode={}, brandNameKo={}",
                row.getStatus(),
                row.getId(),
                row.getBrandCode(),
                row.getBrandNameKo()
            );
            switch (row.getStatus()) {
                case "C" -> {
                    Brand brand = Brand.builder()
                        .brandCode(row.getBrandCode())
                        .shopId(row.getShopId())
                        .steId(row.getSteId())
                        .brandNameKo(row.getBrandNameKo())
                        .brandNameEn(row.getBrandNameEn())
                        .brandDesc(row.getBrandDesc())
                        .useYn(row.getUseYn())
                        .syncStatus("PENDING")   // ← NONE이 아닌 PENDING
                        .build();
                    brandMapper.insert(brand);
                    savedBrandIds.add(brand.getId());
                }
                case "U" -> {
                    Brand brand = brandMapper
                        .findById(row.getId())
                        .orElseThrow(() ->
                            new CustomException(ErrorCode.BRAND_NOT_FOUND)
                        );
                    brand.setBrandNameKo(row.getBrandNameKo());
                    brand.setBrandNameEn(row.getBrandNameEn());
                    brand.setBrandDesc(row.getBrandDesc());
                    brand.setUseYn(row.getUseYn());
                    brandMapper.update(brand);
                    brandMapper.updateSyncStatus(brand.getId(), "PENDING", null);
                    savedBrandIds.add(brand.getId());
                }
                default -> log.warn("알 수 없는 status: {}", row.getStatus());
            }
        }

        return savedBrandIds;
        // ← 여기서 트랜잭션 커밋. DB 커넥션 반환.
    }

    /**
     * 외부 API 호출 (트랜잭션 밖 — DB 커넥션 점유하지 않음)
     * 호출 전후로 brand_sync_history에 이력 기록
     */
    public void syncToExternal(List<Long> brandIds) {
        List<Map<String, Object>> syncList = new ArrayList<>();
        List<BrandSyncHistory> histories = new ArrayList<>();

        // 1. 동기화 데이터 준비 + 이력 PENDING 저장
        for (Long brandId : brandIds) {
            Brand brand = brandMapper.findById(brandId).orElse(null);
            if (brand == null) continue;

            Map<String, Object> syncData = new HashMap<>();
            syncData.put("brandCode", brand.getBrandCode());
            syncData.put("shopId", brand.getShopId());
            syncData.put("brandMid", brand.getSteId());
            syncData.put("brandNameKo", brand.getBrandNameKo());
            syncData.put("brandNameEn", brand.getBrandNameEn());
            syncData.put("brandDesc", brand.getBrandDesc());
            syncData.put("useYn", brand.getUseYn());
            syncList.add(syncData);

            String syncType =
                "NONE".equals(brand.getSyncStatus()) ||
                "PENDING".equals(brand.getSyncStatus())
                    ? "REGISTER"
                    : "UPDATE";
            BrandSyncHistory history = BrandSyncHistory.builder()
                .brandId(brandId)
                .brandCode(brand.getBrandCode())
                .syncType(syncType)
                .syncStatus("PENDING")
                .requestPayload(toJson(syncData))
                .build();
            saveHistory(history);
            histories.add(history);
        }

        if (syncList.isEmpty()) return;

        // 2. 외부 API 호출 (DB 커넥션 점유 안함)
        try {
            log.info("외부 플랫폼 동기화 요청: {}건", syncList.size());
            List<Map<String, Object>> response = brandSyncClient.registerBrands(syncList);
            log.info("외부 플랫폼 동기화 완료");

            String responseJson = toJson(response);

            // 3-A. 성공: 이력 SUCCESS + brand syncStatus SUCCESS
            for (BrandSyncHistory history : histories) {
                completeHistory(history.getId(), "SUCCESS", responseJson, null);
            }
            updateSyncResults(brandIds, "SUCCESS", null);

        } catch (Exception e) {
            log.error("외부 동기화 실패: {}", e.getMessage());

            // 3-B. 실패: 이력 FAILED + brand syncStatus FAILED
            for (BrandSyncHistory history : histories) {
                completeHistory(history.getId(), "FAILED", null, e.getMessage());
            }
            updateSyncResults(brandIds, "FAILED", e.getMessage());
        }
    }

    /**
     * 이력 저장 (별도 트랜잭션)
     */
    @Transactional
    public void saveHistory(BrandSyncHistory history) {
        brandSyncHistoryMapper.insert(history);
    }

    /**
     * 이력 상태 업데이트 (별도 트랜잭션)
     */
    @Transactional
    public void completeHistory(Long historyId, String status, String responsePayload, String errorMessage) {
        brandSyncHistoryMapper.updateStatus(historyId, status, responsePayload, errorMessage);
    }

    /**
     * syncStatus 일괄 업데이트 (별도 트랜잭션)
     */
    @Transactional
    public void updateSyncResults(List<Long> brandIds, String status, String error) {
        for (Long brandId : brandIds) {
            brandMapper.updateSyncStatus(brandId, status, error);
        }
    }

    private String toJson(Object obj) {
        try {
            return objectMapper.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            log.warn("JSON 직렬화 실패: {}", e.getMessage());
            return null;
        }
    }

    @Transactional
    public void saveAll(BrandSaveRequest request) {
        for (BrandSaveRequest.BrandRow row : request.getRows()) {
            switch (row.getStatus()) {
                case "C" -> {
                    Brand brand = Brand.builder()
                        .brandCode(row.getBrandCode())
                        .shopId(row.getShopId())
                        .steId(row.getSteId())
                        .brandNameKo(row.getBrandNameKo())
                        .brandNameEn(row.getBrandNameEn())
                        .brandNameJp(row.getBrandNameJp())
                        .brandNameZhCn(row.getBrandNameZhCn())
                        .brandNameZhTw(row.getBrandNameZhTw())
                        .brandDesc(row.getBrandDesc())
                        .useYn(row.getUseYn())
                        .build();
                    brandMapper.insert(brand);
                }
                case "U" -> {
                    Brand brand = brandMapper
                        .findById(row.getId())
                        .orElseThrow(() ->
                            new CustomException(ErrorCode.BRAND_NOT_FOUND)
                        );

                    brand.setBrandNameKo(row.getBrandNameKo());
                    brand.setBrandNameEn(row.getBrandNameEn());
                    brand.setBrandNameJp(row.getBrandNameJp());
                    brand.setBrandNameZhCn(row.getBrandNameZhCn());
                    brand.setBrandNameZhTw(row.getBrandNameZhTw());
                    brand.setBrandDesc(row.getBrandDesc());
                    brand.setUseYn(row.getUseYn());

                    if (row.getVersion() != null) {
                        brand.setVersion(row.getVersion());
                        int updated = brandMapper.updateWithVersion(brand);
                        if (updated == 0) {
                            throw new CustomException(
                                ErrorCode.BRAND_VERSION_CONFLICT
                            );
                        }
                    } else {
                        brandMapper.update(brand);
                    }
                }
            }
        }
    }
}
```

---

## 핵심 변경 요약

### 트랜잭션 흐름 비교

```
[AS-IS]
┌──────────────── @Transactional ────────────────┐
│  INSERT/UPDATE → 외부 API 호출 → syncStatus 갱신 │
└────────────────────────────────────────────────┘
   DB 커넥션: 전체 시간 동안 점유 (외부 API 포함)

[TO-BE]
┌─ TX#1 ─┐          ┌─ TX#2 ─┐          ┌─ TX#3 ─┐
│ INSERT  │ → 이력  → │  API  │ → 결과 → │ STATUS │
│ UPDATE  │  PENDING  │  호출  │  저장     │ 갱신    │
└─────────┘          └────────┘          └────────┘
  DB 커넥션:          DB 커넥션:           DB 커넥션:
  짧게 사용            점유 안함            짧게 사용
```

### syncStatus 상태 전이

```
NONE → (저장 시) → PENDING → (API 성공) → SUCCESS
                           → (API 실패) → FAILED
```

### 메서드 분리 구조

| 메서드 | @Transactional | 역할 |
|--------|---------------|------|
| `saveAndSync()` | 없음 | 오케스트레이터 — saveBrands → syncToExternal 순서 호출 |
| `saveBrands()` | 있음 (TX#1) | DB INSERT/UPDATE + syncStatus=PENDING |
| `syncToExternal()` | 없음 | 외부 API 호출 + 이력 기록 |
| `saveHistory()` | 있음 (TX#2) | brand_sync_history INSERT (PENDING) |
| `completeHistory()` | 있음 (TX#3) | brand_sync_history UPDATE (SUCCESS/FAILED) |
| `updateSyncResults()` | 있음 (TX#3) | brand.syncStatus 업데이트 |

### 안전장치

- 외부 API 실패해도 DB 데이터는 커밋된 상태 (rollback 안됨)
- FAILED 상태 데이터 = step3에서 재시도 대상
- PENDING 상태로 오래 남은 건 = 프로세스 중단된 건 → 역시 재시도 대상
