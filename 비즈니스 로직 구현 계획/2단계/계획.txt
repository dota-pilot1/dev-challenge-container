===== 2단계: 동시성 문제 재현 + 락으로 해결 =====

목표: 1단계에서 만든 서비스에서 동시성 문제를 재현하고 락으로 해결

======================================================================
  2-1. 문제 재현
======================================================================

  [챌린지 동시 완료 - 서버1]
  시나리오: 같은 개발자가 같은 챌린지를 동시에 2번 완료 요청
  예상 결과: 주문이 2번 들어감 (중복 보상)
  테스트: ExecutorService + CountDownLatch로 동시 요청

  [재고 동시 차감 - 서버2]
  시나리오: 재고 1개인 상품에 동시에 2건 주문
  예상 결과: 재고가 -1이 되거나 2건 다 성공 (초과 차감)
  테스트: 동시 POST /api/orders

  [서버간 정합성 - 서버1 + 서버2]
  시나리오: 서버2 주문 성공 → 서버1 완료 기록 저장 실패
  예상 결과: 주문은 됐는데 완료 이력 없음
  테스트: 서버1에서 의도적 예외 발생

======================================================================
  2-2. 비관적 락으로 해결 (Spring Boot + NestJS)
======================================================================

  [서버1 - Spring Boot]
  - ChallengeCompletion 중복 방지: SELECT FOR UPDATE
  - 같은 member_id + challenge_id 조합 락

  [서버2 - NestJS]
  - 재고 차감 시: SELECT FOR UPDATE on Product
  - Drizzle ORM에서 raw SQL 또는 트랜잭션 활용

  [테스트]
  - 동일 시나리오 재실행 → 문제 해결 확인
  - 처리 시간 측정 (락 대기로 인한 성능 저하 관찰)

======================================================================
  2-3. 낙관적 락으로 해결
======================================================================

  [서버1 - Spring Boot]
  - Challenge, ChallengeCompletion에 version 컬럼 추가
  - 충돌 시 재시도 로직 (최대 3회)

  [서버2 - NestJS]
  - Product에 version 컬럼 추가
  - 재고 차감 시 version 체크

  [비교]
  - 비관적 vs 낙관적 성능 차이 측정
  - 충돌 빈도에 따른 적합한 방식 분석

======================================================================
  2-4. 분산 락으로 해결 (Redis)
======================================================================

  [인프라]
  - Docker Compose에 Redis 추가

  [서버1 - Spring Boot]
  - Redisson 의존성 추가
  - 분산 락 적용: 챌린지 완료 처리

  [서버2 - NestJS]
  - ioredis + redlock 적용
  - 분산 락 적용: 재고 차감

  [테스트]
  - 멀티 인스턴스 시뮬레이션 (같은 서버 2개 실행)
  - 분산 환경에서 동시성 해결 확인

======================================================================
  2-5. 프론트 - 동시성 테스트 페이지
======================================================================

  [Concurrency Test 페이지]
  - 테스트 시나리오 선택 (챌린지 중복 / 재고 초과 / 분산 트랜잭션)
  - 동시 요청 수 설정 (슬라이더: 2~50)
  - 발사 버튼 → Promise.all로 동시 요청
  - 결과 시각화:
    - 성공/실패 카운트
    - 예상 vs 실제 (재고, 완료 횟수)
    - 정합성 깨짐 여부 (빨간색/초록색)
  - 락 방식 선택 (없음 / 비관적 / 낙관적 / 분산)으로 비교

======================================================================
  2단계 완료 기준
======================================================================

  - 동시성 문제 3가지 재현 성공
  - 비관적 / 낙관적 / 분산 락으로 각각 해결
  - 프론트에서 시각적으로 문제와 해결을 비교 가능
  - 각 방식의 성능 차이 데이터 확보
