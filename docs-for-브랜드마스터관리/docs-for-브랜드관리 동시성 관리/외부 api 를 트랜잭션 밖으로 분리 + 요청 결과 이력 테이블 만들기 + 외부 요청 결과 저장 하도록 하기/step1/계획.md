# Step 1: 외부 API 호출을 트랜잭션 밖으로 분리

## 현재 문제 (AS-IS)

```java
@Transactional  // ← 하나의 트랜잭션이 전부를 감쌈
public void saveAndSync(BrandSaveRequest request) {
    // 1. DB 저장 (INSERT/UPDATE)
    for (BrandSaveRequest.BrandRow row : request.getRows()) {
        switch (row.getStatus()) {
            case "C" -> brandMapper.insert(brand);
            case "U" -> brandMapper.update(brand);
        }
    }

    // 2. 외부 API 호출 (문제의 핵심!)
    brandSyncClient.registerBrands(syncList);

    // 3. syncStatus SUCCESS 업데이트
    brandMapper.updateSyncStatus(brandId, "SUCCESS", null);
}
```

### 발생하는 문제 3가지

| 문제 | 상황 | 결과 |
|------|------|------|
| **정합성 깨짐** | 외부 API 성공 → 후속 처리 중 예외 → DB 롤백 | 외부는 반영됨, 내부 DB는 롤백 |
| **커넥션 낭비** | 외부 API 타임아웃 (5~30초) | DB 커넥션이 그 시간 동안 점유됨 |
| **동시성 경합** | 같은 brandCode에 동시 요청 | 트랜잭션 장시간 보유 → lock 대기 |

## 변경 계획 (TO-BE)

```
[요청] → [DB 트랜잭션: INSERT/UPDATE + syncStatus=PENDING]
                         ↓ (트랜잭션 커밋 완료)
       → [트랜잭션 밖: 외부 API 호출]
                         ↓
       → [새 트랜잭션: syncStatus=SUCCESS 또는 FAILED 업데이트]
```

### 변경 대상 파일

| 파일 | 변경 내용 |
|------|-----------|
| `BrandService.java` | `saveAndSync` → DB 저장과 외부 API 호출 분리 |

### 핵심 변경 내용

1. **DB 저장 메서드** (`saveBrands`) — `@Transactional`
   - INSERT/UPDATE 실행
   - `syncStatus = 'PENDING'` 으로 저장 (기존 'NONE' → 'PENDING')
   - 저장된 brand ID 목록 리턴

2. **외부 API 호출 메서드** (`syncToExternal`) — 트랜잭션 없음
   - `brandSyncClient.registerBrands()` 호출
   - 성공/실패에 따라 syncStatus 업데이트

3. **통합 메서드** (`saveAndSync`) — 트랜잭션 없음 (각 단계가 자체 트랜잭션)
   - `saveBrands()` 호출 → 커밋
   - `syncToExternal()` 호출 → 성공/실패 처리

### 기대 효과

- DB 커넥션은 INSERT/UPDATE 시에만 사용 (외부 API 대기 동안 점유 안함)
- 외부 API 실패해도 DB 데이터는 이미 커밋되어 안전
- `syncStatus = PENDING` 상태로 남은 건 = 재시도 대상 (step3에서 활용)
