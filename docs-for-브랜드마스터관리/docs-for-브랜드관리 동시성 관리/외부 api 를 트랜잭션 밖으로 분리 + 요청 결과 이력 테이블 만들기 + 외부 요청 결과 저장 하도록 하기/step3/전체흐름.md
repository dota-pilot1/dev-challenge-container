# Step 1~3 완료 후 전체 흐름 요약

## 전체 아키텍처

```
[프론트엔드]  POST /api/brands/save-and-sync
     │
     ▼
[BrandController]
     │
     ▼
[BrandService.saveAndSync()]   ← 트랜잭션 없음 (오케스트레이터)
     │
     ├─ [1] saveBrands()        ← @Transactional (TX#1)
     │     INSERT/UPDATE brand
     │     syncStatus = PENDING
     │     return savedIds
     │
     ├─ [2] syncToExternal()    ← 트랜잭션 없음
     │     │
     │     ├─ brand_sync_history INSERT (PENDING)  ← @Transactional (TX#2)
     │     │
     │     ├─ brandSyncClient.registerBrands()     ← HTTP 호출 (DB 커넥션 없음!)
     │     │
     │     └─ 결과에 따라:
     │          ├─ 성공 → history=SUCCESS, brand.syncStatus=SUCCESS  ← TX#3
     │          └─ 실패 → history=FAILED, brand.syncStatus=FAILED   ← TX#3
     │
     └─ [3] 응답 반환
```

## 데이터 흐름

```
brand 테이블:
  syncStatus: NONE → PENDING → SUCCESS / FAILED

brand_sync_history 테이블:
  매 API 호출마다 1건 INSERT
  ┌─────────┬──────────┬──────────┬─────────────────┬──────────┐
  │ brandId │ syncType │  status  │ request_payload │  error   │
  ├─────────┼──────────┼──────────┼─────────────────┼──────────┤
  │    1    │ REGISTER │ SUCCESS  │ {"brandCode":…} │   null   │
  │    2    │ REGISTER │ FAILED   │ {"brandCode":…} │ timeout  │
  │    2    │ REGISTER │ SUCCESS  │ {"brandCode":…} │   null   │  ← 재시도 성공
  └─────────┴──────────┴──────────┴─────────────────┴──────────┘
```

## AS-IS vs TO-BE 비교

| 항목 | AS-IS (현재) | TO-BE (step1~3 완료 후) |
|------|-------------|----------------------|
| 트랜잭션 범위 | DB저장 + 외부API + 상태갱신 전부 | DB저장만. 외부API는 밖 |
| DB 커넥션 점유 | 외부 API 대기 포함 전체 | INSERT/UPDATE 시에만 |
| 외부 API 실패 시 | DB 롤백 (데이터 유실) | DB 커밋 유지 (안전) |
| 실패 추적 | sync_status만 | 이력 테이블로 상세 추적 |
| 재시도 | 불가 | 이력 기반 재시도 가능 |
| 요청/응답 기록 | 없음 | payload JSON 저장 |

## 향후 확장 (이 단계에서는 안 함)

- **자동 재시도 스케줄러**: FAILED 건 자동 재처리
- **이력 조회 UI**: 프론트에서 동기화 이력 확인
- **알림**: FAILED 건 발생 시 Slack/이메일 알림
- **낙관적 락 적용**: 동시 수정 충돌 방지 (별도 시나리오)
