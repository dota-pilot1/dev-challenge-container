# Step 2: 외부 API 요청 이력 테이블 생성

## 목적

brand 테이블의 `sync_status` 컬럼만으로는 부족하다:
- 언제 요청했는지 (타임스탬프)
- 몇 번째 시도인지
- 어떤 에러가 났는지 (상세)
- 요청/응답 payload는 뭐였는지

**별도 이력 테이블**을 만들어 모든 외부 API 호출을 기록한다.

## 테이블 설계

### brand_sync_history (신규)

```sql
CREATE TABLE brand_sync_history (
    id              BIGSERIAL PRIMARY KEY,
    brand_id        BIGINT NOT NULL,           -- brand.id FK
    brand_code      VARCHAR(50) NOT NULL,      -- 조회 편의용
    sync_type       VARCHAR(20) NOT NULL,      -- REGISTER, UPDATE, DELETE
    sync_status     VARCHAR(20) NOT NULL,      -- PENDING, SUCCESS, FAILED
    request_payload TEXT,                       -- 요청 데이터 (JSON)
    response_payload TEXT,                      -- 응답 데이터 (JSON)
    error_message   TEXT,                       -- 실패 시 에러 메시지
    retry_count     INT DEFAULT 0,             -- 재시도 횟수
    created_at      TIMESTAMP DEFAULT NOW(),   -- 요청 시각
    completed_at    TIMESTAMP,                 -- 완료 시각

    CONSTRAINT fk_brand_sync_history_brand
        FOREIGN KEY (brand_id) REFERENCES brand(id) ON DELETE CASCADE
);

CREATE INDEX idx_brand_sync_history_brand_id ON brand_sync_history(brand_id);
CREATE INDEX idx_brand_sync_history_status ON brand_sync_history(sync_status);
CREATE INDEX idx_brand_sync_history_created ON brand_sync_history(created_at);
```

### 컬럼 설명

| 컬럼 | 설명 | 예시 |
|------|------|------|
| `brand_id` | 어떤 브랜드에 대한 이력인지 | 1 |
| `brand_code` | 브랜드 코드 (조회 편의) | "BR001" |
| `sync_type` | 어떤 종류의 동기화인지 | REGISTER / UPDATE / DELETE |
| `sync_status` | 현재 상태 | PENDING → SUCCESS 또는 FAILED |
| `request_payload` | 외부 API에 보낸 데이터 | `{"brandCode":"BR001","brandNameKo":"나이키",...}` |
| `response_payload` | 외부 API 응답 데이터 | `{"id":1,"brandCode":"BR001",...}` |
| `error_message` | 실패 원인 | "Connection timed out" |
| `retry_count` | 재시도 횟수 | 0, 1, 2, 3 |
| `created_at` | 요청 시작 시각 | 2026-02-16 21:45:00 |
| `completed_at` | 완료 시각 (성공/실패 확정) | 2026-02-16 21:45:02 |

## 변경 대상

| 파일 | 변경 내용 |
|------|-----------|
| `V7__create_brand_sync_history.sql` | Flyway 마이그레이션 — 테이블 생성 |
| `BrandSyncHistory.java` | 엔티티 클래스 (신규) |
| `BrandSyncHistoryMapper.java` | MyBatis 매퍼 인터페이스 (신규) |
| `BrandSyncHistoryMapper.xml` | MyBatis XML 매퍼 (신규) |

## 핵심 매퍼 메서드

```java
@Mapper
public interface BrandSyncHistoryMapper {
    void insert(BrandSyncHistory history);
    void updateStatus(@Param("id") Long id,
                      @Param("syncStatus") String syncStatus,
                      @Param("responsePayload") String responsePayload,
                      @Param("errorMessage") String errorMessage);
    List<BrandSyncHistory> findByBrandId(@Param("brandId") Long brandId);
    List<BrandSyncHistory> findByStatus(@Param("syncStatus") String syncStatus);
    void incrementRetryCount(@Param("id") Long id);
}
```

## 이 단계에서는 테이블만 만든다

- 아직 이 테이블에 데이터를 저장하는 코드는 작성하지 않음
- step3에서 실제로 외부 API 호출 전후에 이력을 저장하는 로직을 추가
