## Problem 5: 주문 성공 후 후속 처리 실패 시 보상 트랜잭션 (Saga 패턴)

### 문제 상황

현재 approve() 흐름:
  1. shopClient.createOrder()  → shop-api에 주문 생성 (외부 API 호출)
  2. participationMapper.updateOrderId()  → 참가에 주문 ID 저장
  3. participationMapper.updateStatus("APPROVED")  → 참가 상태를 승인으로 변경
  4. approvalHistoryMapper.insert()  → 이력 기록

1번(주문 생성)은 성공했는데 2~4번(후속 DB 처리)에서 예외가 발생하면?
→ shop-api에는 주문이 존재하지만, concurrency-lab에서는 승인 처리가 안 된 상태
→ 재고는 차감됐고 주문은 생성됐지만 아무도 모르는 "유령 주문" 발생
→ @Transactional로 롤백되어도 외부 API(shop-api) 호출은 되돌릴 수 없음


### 핵심 원인

- concurrency-lab과 shop-api는 서로 다른 DB를 사용하는 분산 시스템
- Spring의 @Transactional은 자신의 DB만 롤백 가능
- 외부 HTTP 호출(shopClient.createOrder)은 트랜잭션에 포함되지 않음
- 따라서 "주문 생성은 성공 + 후속 처리는 실패"라는 불일치가 발생할 수 있음


### 해결: 보상 트랜잭션 (Compensating Transaction)

주문 생성 후 후속 처리가 실패하면, shop-api에 주문 취소 요청을 보내서 원래 상태로 되돌린다.

수정된 approve() 흐름:
  1. shopClient.createOrder()  → 주문 생성
  2. participationMapper.updateOrderId()  → 주문 ID 저장
  3. participationMapper.updateStatus("APPROVED")  → 상태 변경
  4. approvalHistoryMapper.insert()  → 이력 기록

  만약 2~4에서 예외 발생 시:
  5. shopClient.cancelOrder(orderId)  → 주문 취소 (보상 트랜잭션)
  6. 주문 취소 시 shop-api에서 재고 복구도 자동 처리됨


### 구현 계획

#### 1. shop-api 측 (이미 존재하는 기능 활용)
- order.service.ts의 updateStatus() 메서드에 CANCELLED 처리 로직이 이미 있음
- 취소 시 재고 자동 복구 로직도 구현되어 있음
- PATCH /api/orders/:id/status { status: "CANCELLED" } 엔드포인트 사용

#### 2. concurrency-lab 측
- ShopClient에 cancelOrder(int orderId) 메서드 추가
  - PATCH /api/orders/{id}/status 호출, body: { "status": "CANCELLED" }

- ParticipationService.approve() 수정
  - 주문 생성 성공 후 후속 처리를 별도 try-catch로 감싸기
  - 후속 처리 실패 시 shopClient.cancelOrder() 호출
  - 보상 트랜잭션도 실패하면 로그에 남기고 APPROVE_FAILED 처리
    (이 경우 수동 확인이 필요한 상태)

- ParticipationService.retryApprove()도 동일하게 적용

#### 3. 테스트 방법
- 후속 처리 실패를 인위적으로 발생시키기 어려우므로:
  - 임시로 updateOrderId() 직후에 강제 예외를 던지는 코드 추가
  - 승인 실행 → 주문이 생성됐다가 취소되는지 확인
  - shop-api의 주문 상태가 CANCELLED로 변경되었는지 확인
  - 상품 재고가 원래대로 복구되었는지 확인
  - 테스트 후 강제 예외 코드 제거


### 보상 트랜잭션의 한계

- 보상 트랜잭션(cancelOrder) 자체도 실패할 수 있음
  → 이 경우 "주문은 생성됐지만 취소도 안 된" 최악의 상태
  → 로그를 남기고 관리자가 수동으로 처리해야 함
  → 실무에서는 스케줄러로 불일치 상태를 주기적으로 감지/복구하는 방식 사용
