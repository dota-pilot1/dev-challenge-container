데이터 추가 로직 (신규 버튼)
=============================


1. 신규 버튼 클릭
==================

  const handleAdd = useCallback(() => {
    if (!tabulatorRef.current) return;
    const newRow: RowData = {
      id: null,                 // PK 없음
      email: "",                // 빈 값 (사용자가 직접 입력)
      nickname: "",             // 빈 값 (사용자가 직접 입력)
      createdAt: "",            // 빈 값 (서버에서 NOW() 처리)
      _flag: "C",               // 신규 플래그
    };
    tabulatorRef.current.addRow(newRow, false);  // false = 맨 아래에 추가
  }, []);


2. 그리드 표시 상태
=====================

  신규 행이 추가되면 그리드에 즉시 반영된다.

  | 체크 | ID   | 이메일 | 닉네임 | 가입일 | 상태 |
  |------|------|--------|--------|--------|------|
  | []   | 1    | test@  | test   | 2026.. |      |
  | []   | 2    | tere.. | hyun.. | 2026.. |      |
  | []   | NEW  | (빈칸) | (빈칸) | (빈칸) | 신규 |  ← 추가된 행

  * ID 컬럼: _flag === "C"이므로 formatter가 "NEW" 출력
  * 상태 컬럼: _flag === "C"이므로 초록색 "신규" 출력
  * 이메일/닉네임: 빈칸, 셀 클릭하면 editor: "input"으로 직접 입력


3. 셀 편집 시 changedRows에 등록
=================================

  신규 행의 이메일이나 닉네임을 입력하면 cellEdited 이벤트가 발생한다.

  table.on("cellEdited", (cell: CellComponent) => {
    const data = cell.getRow().getData() as RowData;
    // 이미 _flag: "C"이므로 "U"로 덮어쓰지 않음
    if (!data._flag) {
      data._flag = "U";
      cell.getRow().update({ _flag: "U" });
    }
    setChangedRows((prev) => {
      const next = new Map(prev);
      next.set(getRowKey(data), { ...data });   // key: "new_이메일"
      return next;
    });
  });

  * 신규 행은 이미 _flag: "C"이므로 if (!data._flag) 조건에 걸리지 않음
  * _flag가 "C"인 채로 changedRows에 저장됨


4. 저장 시 서버 전송
=====================

  changedRows에서 _flag: "C"인 행을 수집 → status: "C"로 변환

  { email: "new@test.com", nickname: "신규유저", status: "C" }

  → 서버에서 existsByEmail 중복 체크 → insert
