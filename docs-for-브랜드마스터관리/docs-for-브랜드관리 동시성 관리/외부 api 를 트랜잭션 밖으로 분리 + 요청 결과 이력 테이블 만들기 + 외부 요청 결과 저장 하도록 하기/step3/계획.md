# Step 3: 외부 API 호출 시 이력 저장 + 재시도 근거 마련

## 목적

step1에서 분리한 `syncToExternal()` 메서드가 외부 API를 호출할 때,
step2에서 만든 `brand_sync_history` 테이블에 매 호출마다 이력을 기록한다.

이력이 있으면:
- 실패한 건을 조회해서 **재시도** 할 수 있다
- 언제, 왜 실패했는지 **추적**할 수 있다
- 요청/응답 payload를 보고 **디버깅**할 수 있다

## 동작 흐름

```
saveAndSync 호출
  │
  ├─ [TX#1] saveBrands() : DB INSERT/UPDATE + syncStatus=PENDING
  │
  ├─ [트랜잭션 없음] syncToExternal()
  │    │
  │    ├─ [TX#2] brand_sync_history INSERT (status=PENDING, request_payload 저장)
  │    │
  │    ├─ 외부 API 호출 (brandSyncClient.registerBrands)
  │    │
  │    ├─ 성공 시:
  │    │    └─ [TX#3] brand_sync_history UPDATE (status=SUCCESS, response_payload 저장)
  │    │    └─ [TX#3] brand.sync_status = SUCCESS
  │    │
  │    └─ 실패 시:
  │         └─ [TX#3] brand_sync_history UPDATE (status=FAILED, error_message 저장)
  │         └─ [TX#3] brand.sync_status = FAILED
  │
  └─ 완료 (실패해도 예외 throw 안함 — DB 데이터는 안전)
```

## 변경 대상

| 파일 | 변경 내용 |
|------|-----------|
| `BrandService.java` | `syncToExternal()`에 이력 저장 로직 추가 |
| `BrandSyncHistoryMapper.java` | step2에서 만든 매퍼 활용 |

## 핵심 코드 변경

### BrandService.syncToExternal() 수정

```java
public void syncToExternal(List<Long> brandIds) {
    List<Map<String, Object>> syncList = new ArrayList<>();
    List<BrandSyncHistory> histories = new ArrayList<>();

    // 1. 동기화 데이터 준비 + 이력 PENDING 저장
    for (Long brandId : brandIds) {
        Brand brand = brandMapper.findById(brandId).orElse(null);
        if (brand == null) continue;

        Map<String, Object> syncData = buildSyncData(brand);
        syncList.add(syncData);

        // 이력 저장 (PENDING)
        BrandSyncHistory history = BrandSyncHistory.builder()
            .brandId(brandId)
            .brandCode(brand.getBrandCode())
            .syncType(brand.getSyncStatus().equals("NONE") ? "REGISTER" : "UPDATE")
            .syncStatus("PENDING")
            .requestPayload(toJson(syncData))
            .build();
        brandSyncHistoryMapper.insert(history);
        histories.add(history);
    }

    if (syncList.isEmpty()) return;

    // 2. 외부 API 호출
    try {
        List<Map<String, Object>> response = brandSyncClient.registerBrands(syncList);

        // 3-A. 성공: 이력 + brand 상태 업데이트
        for (BrandSyncHistory history : histories) {
            brandSyncHistoryMapper.updateStatus(
                history.getId(), "SUCCESS", toJson(response), null);
        }
        updateSyncResults(brandIds, "SUCCESS", null);

    } catch (Exception e) {
        // 3-B. 실패: 이력 + brand 상태 업데이트
        for (BrandSyncHistory history : histories) {
            brandSyncHistoryMapper.updateStatus(
                history.getId(), "FAILED", null, e.getMessage());
        }
        updateSyncResults(brandIds, "FAILED", e.getMessage());
        log.error("외부 동기화 실패: {}", e.getMessage());
    }
}
```

## 재시도 근거

이 이력 테이블이 존재하면, 향후 다음 기능들을 만들 수 있다:

| 기능 | 방법 |
|------|------|
| **수동 재시도** | FAILED 상태 이력 조회 → request_payload 그대로 재전송 |
| **자동 재시도 (스케줄러)** | `@Scheduled`로 FAILED/PENDING 건 주기적 재시도 |
| **재시도 횟수 제한** | `retry_count >= 3`이면 포기 (ABANDONED 상태) |
| **모니터링** | FAILED 건수 대시보드, 알림 연동 |

## 이 단계에서 프론트엔드는 변경 없음

- 프론트에서 보내는 요청은 동일 (`POST /api/brands/save-and-sync`)
- 응답도 동일 (200 OK)
- 이력 조회 UI는 향후 필요 시 별도 추가
